{"version":3,"file":"memoize.js","sourceRoot":"","sources":["src/memoize.ts"],"names":[],"mappings":";;AAAA,wCAA2C;AAE3C,qCAKmB;AACnB,6CAAkD;AAGlD,IAAM,SAAS,GAAG,0BAAgB,CAAC,uBAAuB,CACxD,IAAI,yBAAe,CAAC,OAAO,EAAE,IAAI,+BAAiB,EAAE,CAAC,CACtD,CAAC;AAEF;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,iBAAwB,QAAuD;IAC7E,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;AAC7B,CAAC;AAFD,0BAEC;AACmB,0BAAO;AAC3B,kBAAe,SAAS,CAAC","sourcesContent":["import memoize = require('lodash/memoize');\n\nimport {\n  DecoratorConfig,\n  DecoratorFactory,\n  LodashMethodDecorator,\n  ResolvableFunction\n} from './factory';\nimport { MemoizeApplicator } from './applicators';\nimport { MemoizeConfig } from './shared';\n\nconst decorator = DecoratorFactory.createInstanceDecorator(\n  new DecoratorConfig(memoize, new MemoizeApplicator())\n);\n\n/**\n * Creates a function that memoizes the result of func. If resolver is provided,\n * it determines the cache key for storing the result based on the arguments provided to the memoized function.\n * By default, the first argument provided to the memoized function is used as the map cache key.\n * The func is invoked with the this binding of the memoized function.\n *\n * You can use a Function or a string that references a method on the class as the resolver.\n * You can also use a configuration object that lets provide a prexisting cache or specify\n * the map type to use.\n *\n * @example\n *\n * class MyClass {\n *   @Memoize({ type: WeakMap })\n *   getName(item) {\n *     return item.name;\n *   }\n *\n *   @Memoize('getName')\n *   getLastName(item) {\n *     return item.lastName;\n *   }\n * }\n */\nexport function Memoize(resolver?: ResolvableFunction | MemoizeConfig<any, any>): LodashMethodDecorator {\n  return decorator(resolver);\n}\nexport { Memoize as memoize };\nexport default decorator;\n"]}