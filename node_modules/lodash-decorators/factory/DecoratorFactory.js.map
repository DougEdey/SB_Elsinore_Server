{"version":3,"file":"DecoratorFactory.js","sourceRoot":"","sources":["../src/factory/DecoratorFactory.ts"],"names":[],"mappings":"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","sourcesContent":["import isFunction = require('lodash/isFunction');\n\nimport {\n  InstanceChainMap,\n  LodashDecorator,\n  InstanceChainContext\n} from './common';\nimport { DecoratorConfig } from './DecoratorConfig';\nimport { copyMetadata, bind } from '../utils';\n\nexport type GenericDecorator = (...args: any[]) => LodashDecorator;\n\nexport class InternalDecoratorFactory {\n  createDecorator(config: DecoratorConfig): GenericDecorator {\n    const { applicator } = config;\n\n    return (...args: any[]): LodashDecorator => {\n      return (target: Object, name: string, _descriptor?: PropertyDescriptor): PropertyDescriptor => {\n        const descriptor = this._resolveDescriptor(target, name, _descriptor);\n        const { value, get, set } = descriptor;\n\n        // If this decorator is being applied after an instance decorator we simply ignore it\n        // as we can't apply it correctly.\n        if (!InstanceChainMap.has([ target, name ])) {\n          if (isFunction(value)) {\n            descriptor.value = copyMetadata(applicator.apply({ config, target, value, args }), value);\n          } else if (isFunction(get) && config.getter) {\n            descriptor.get = copyMetadata(applicator.apply({ config, target, value: get, args }), get);\n          } else if (isFunction(set) && config.setter) {\n            descriptor.set = copyMetadata(applicator.apply({ config, target, value: set, args }), get);\n          }\n        }\n\n        return descriptor;\n      };\n    };\n  }\n\n  createInstanceDecorator(config: DecoratorConfig): GenericDecorator {\n    const { applicator, bound } = config;\n\n    return (...args: any[]): LodashDecorator => {\n      return (target: Object, name: string, _descriptor?: PropertyDescriptor): PropertyDescriptor => {\n        const descriptor = this._resolveDescriptor(target, name, _descriptor);\n        const { value, writable, enumerable, configurable, get, set } = descriptor;\n        const isFirstInstance = !InstanceChainMap.has([ target, name ]);\n        const chainData = InstanceChainMap.get([ target, name ]) || { fns: [], properties: [] };\n        const isGetter = isFirstInstance && isFunction(get);\n        const isSetter = isFirstInstance && isFunction(set);\n        const isMethod = isFirstInstance && isFunction(value);\n        const isProperty = isFirstInstance && !isGetter && !isSetter && !isMethod;\n\n        chainData.properties.push(name);\n        chainData.fns.push((fn: Function, instance: any, context: InstanceChainContext) => {\n          if (!this._isApplicable(context, config)) {\n            return fn;\n          }\n\n          if (bound) {\n            fn = bind(fn, instance);\n          }\n\n          return copyMetadata(\n            applicator.apply({ args, target, instance, value: fn, config }),\n            fn\n          );\n        });\n\n        InstanceChainMap.set([ target, name ], chainData);\n\n        if (!isFirstInstance) {\n          return descriptor;\n        }\n\n        chainData.isSetter = isSetter;\n        chainData.isGetter = isGetter;\n        chainData.isMethod = isMethod;\n        chainData.isProperty = isProperty;\n\n        const applyChain = (fn: any, context: InstanceChainContext, instance: any) => {\n          return chainData.fns.reduce((result: Function, next: Function) => next(result, instance, context), fn);\n        };\n\n        const applyDecorator = (instance: any) => {\n          let getter = get || undefined;\n          let setter = set || undefined;\n\n          if (isGetter || isSetter) {\n            // If we have a getter apply the decorators to the getter and assign it to the instance.\n            if (isGetter) {\n              getter = applyChain(get, { value: get, getter: true }, instance);\n            }\n\n            if (isSetter) {\n              setter = applyChain(set, { value: set, setter: true }, instance);\n            }\n\n            Object.defineProperty(instance, name, {\n              enumerable,\n              configurable,\n              get: getter,\n              set: setter\n            });\n          } else if (isMethod || isProperty) {\n            const newFn = isMethod\n              ? applyChain(value, { value, method: true }, instance)\n              : applyChain(value, { value, property: true }, instance);\n\n            Object.defineProperty(instance, name, {\n              writable,\n              enumerable,\n              configurable,\n              value: newFn\n            });\n          }\n        }\n\n        if (isMethod || isProperty) {\n          delete descriptor.value;\n          delete descriptor.writable;\n        }\n\n        descriptor.get = function() {\n          applyDecorator(this);\n\n          const descriptor = Object.getOwnPropertyDescriptor(this, name);\n\n          if (descriptor.get) {\n            return descriptor.get.call(this);\n          }\n\n          return descriptor.value;\n        };\n\n        descriptor.set = function(value) {\n          applyDecorator(this);\n\n          const descriptor = Object.getOwnPropertyDescriptor(this, name);\n\n          if (descriptor.set) {\n            descriptor.set.call(this, value);\n          } else if (isProperty || isMethod) {\n            this[name] = value;\n          }\n        };\n\n        return descriptor;\n      };\n    };\n  }\n\n  private _isApplicable(context: InstanceChainContext, config: DecoratorConfig): boolean {\n   return !Boolean(\n     context.getter && !config.getter\n      || context.setter && !config.setter\n      || context.method && !config.method\n      || context.property && !config.property\n   );\n  }\n\n  private _resolveDescriptor(target: Object, name: string, descriptor?: PropertyDescriptor): PropertyDescriptor {\n    if (descriptor) {\n      return descriptor;\n    }\n\n    return Object.getOwnPropertyDescriptor(target, name) || {};\n  }\n}\n\nexport const DecoratorFactory = new InternalDecoratorFactory();\n"]}