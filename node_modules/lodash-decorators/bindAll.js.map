{"version":3,"file":"bindAll.js","sourceRoot":"","sources":["src/bindAll.ts"],"names":[],"mappings":";;AAAA,8CAAiD;AAEjD,iCAAwD;AACxD,qCAA6C;AAE7C;;;;;;;;;;;;;;;;;;;;;;GAsBG;AACH,iBAAwB,OAAsB;IAAtB,wBAAA,EAAA,YAAsB;IAC5C,MAAM,CAAC,UAAC,MAAgB;QACtB,MAAM,CAAC,uBAAe,CAAC,MAAM,EAAE,UAAS,IAAc;YAAE,cAAc;iBAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;gBAAd,6BAAc;;YACpE,cAAc,CAAC,MAAM,EAAE,IAAI,EAAE,OAAO,CAAC,CAAC;YAEtC,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QACzB,CAAC,CAAC,CAAC;IACL,CAAC,CAAC;AACJ,CAAC;AARD,0BAQC;AAsCmB,0BAAO;AApC3B,wBAAwB,MAAgB,EAAE,QAAa,EAAE,OAAsB;IAAtB,wBAAA,EAAA,YAAsB;IAC7E,IAAI,KAAK,GAAG,MAAM,CAAC,SAAS,CAAC;IAE7B,OAAO,KAAK,IAAI,KAAK,KAAK,MAAM,CAAC,SAAS,EAAE,CAAC;QAC3C,GAAG,CAAC,CAAc,UAAiC,EAAjC,KAAA,MAAM,CAAC,mBAAmB,CAAC,KAAK,CAAC,EAAjC,cAAiC,EAAjC,IAAiC;YAA9C,IAAM,GAAG,SAAA;YACZ,IAAM,OAAO,GAAG,OAAO,CAAC,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG,IAAI,CAAC;YACpE,IAAM,UAAU,GAAG,MAAM,CAAC,wBAAwB,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;YAE/D,EAAE,CAAC,CAAC,OAAO,IAAI,GAAG,KAAK,aAAa,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;gBACtE,kEAAkE;gBAClE,2EAA2E;gBAC3E,EAAE,CAAC,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC;oBACnB,IAAM,SAAS,GAAG,0BAAgB,CAAC,GAAG,CAAC,CAAE,KAAK,EAAE,GAAG,CAAE,CAAC,CAAC;oBAEvD,EAAE,CAAC,CAAC,CAAC,SAAS,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC;wBACtC,QAAQ,CAAC;oBACX,CAAC;gBACH,CAAC;gBAED,IAAM,KAAK,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC;gBAE5B,EAAE,CAAC,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;oBACtB,MAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,GAAG,EAAE;wBACnC,YAAY,EAAE,IAAI;wBAClB,UAAU,EAAE,UAAU,CAAC,UAAU;wBACjC,KAAK,EAAE,oBAAY,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,KAAK,CAAC;wBAChD,QAAQ,EAAE,UAAU,CAAC,QAAQ;qBAC9B,CAAC,CAAC;gBACL,CAAC;YACH,CAAC;SACF;QAED,KAAK,GAAG,MAAM,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;IACvC,CAAC;AACH,CAAC;AAGD,kBAAe,OAAO,CAAC","sourcesContent":["import isFunction = require('lodash/isFunction');\n\nimport { copyMetadata, wrapConstructor } from './utils';\nimport { InstanceChainMap } from './factory';\n\n/**\n * Binds methods of an object to the object itself, overwriting the existing method.\n * @export\n * @param {string[]} [methods=[]]\n * @returns {ClassDecorator}\n * @example\n *\n * @BindAll()\n * class MyClass {\n *   bound() {\n *     return this;\n *   }\n *\n *   unbound() {\n *     return this;\n *   }\n * }\n *\n * const myClass = new MyClass();\n *\n * myClass.bound.call(null); // => MyClass {}\n * myClass.unbound.call(null); // => MyClass {}\n */\nexport function BindAll(methods: string[] = []): ClassDecorator {\n  return (target: Function): Function => {\n    return wrapConstructor(target, function(Ctor: Function, ...args: any[]) {\n      bindAllMethods(target, this, methods);\n\n      Ctor.apply(this, args);\n    });\n  };\n}\n\nfunction bindAllMethods(target: Function, instance: any, methods: string[] = []): void {\n  let proto = target.prototype;\n\n  while (proto && proto !== Object.prototype) {\n    for (const key of Object.getOwnPropertyNames(proto)) {\n      const include = methods.length ? methods.indexOf(key) !== -1 : true;\n      const descriptor = Object.getOwnPropertyDescriptor(proto, key);\n\n      if (include && key !== 'constructor' && !instance.hasOwnProperty(key)) {\n        // If this property is a getter and it's NOT an instance decorated\n        // method, ignore it. Instance decorators are getters until first accessed.\n        if (descriptor.get) {\n          const chainData = InstanceChainMap.get([ proto, key ]);\n\n          if (!chainData || !chainData.isMethod) {\n            continue;\n          }\n        }\n\n        const value = instance[key];\n\n        if (isFunction(value)) {\n          Object.defineProperty(instance, key, {\n            configurable: true,\n            enumerable: descriptor.enumerable,\n            value: copyMetadata(value.bind(instance), value),\n            writable: descriptor.writable\n          });\n        }\n      }\n    }\n\n    proto = Object.getPrototypeOf(proto);\n  }\n}\n\nexport { BindAll as bindAll };\nexport default BindAll;\n"]}